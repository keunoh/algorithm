1. 문제를 읽고 이해한다.
    팰린드롬 : 앞에서부터 읽었을 때와 뒤에서부터 읽었을 때가 같은 문자열을 말한다.
    주어진 재귀함수가 있었는데 만약 주어진 문자배열이 팰린드롬이라면 1을 반환하고 0을 반환한다.
    여기서 내가 추가로 해야할 일은 몇 번 recursive를 호출했는지 count를 세고
    팰린드롬 반환값과 호출 count 값을 함께 반환하는 것이다.

2. 문제를 익숙한 용어로 재정의한다.
    아직 어떤 방식으로 하는지 모르겠음

3. 어떻게 해결할지 계획을 세운다.
    우선 이 재귀함수가 어떻게 동작하는지 판단하기로 했다.
    기존 isPalindrome 함수는 단순히 문자배열만 받는 구조였고,
    그 안에 recursion 함수는 세 개의 파라미터를 받는 구조였다.
    1. 문자열, 0, 문자열의길이 -1
        처음에 이 세개의 파라미터가 무엇을 의미하는지 몰라서 recursion 함수를 파악하려했다.
    2. 기저사례 부터 파악해 보았는데 단순히 중간 파라미터가 마지막 파라미터보다 크거나 같다면 종료하는 구조였다.
    3. 그 다음 조건 s[l] != s[r] 여기서 힌트를 얻었는데 이는 문자배열의 맨 처음 인덱스와 맨 마지막 인덱스를 비교하고
    만약 다를 시 return 0 즉, 팰린드롬 문자열이 아니다. 결국 선행 인덱스 와 후행 인덱스를 비교하면서
    중간으로 향해가는 recursion 이라는 것을 알았다.
    4. 그 외의 경우는 recursion을 재귀호출 인덱스 값을 수정시켜주는 방식이었다.
    -- 해결 계획
    5. 맨 처음에 들었던 생각은 마지막의 문자열의 길이에 따라 2로 나누어서 몫을 반환하면 될줄 알았으나
    중간에 팰린드롬이 아닌 경우에도 몇 번 재귀호출을 하는지도 count를 반환해야한다는 사실을 몰랐다.
    결과값을 제대로 보지 않아 놓칠 수도 있었다.
    6. 그래서 count를 recursive 함수를 호출할 때마다 증가시켜주는 방식으로 파라미터를 한 개 더 추가하기로 했다.
    그리고 반환값은 int[]로 해서 [0]에는 팰린드롬 반환값이, [1]에는 함수 호출 횟수 값이 들어가도록 했다.

4. 계획을 검증한다.
    어떤 방식으로 하는지 모르겠음

5. 프로그램으로 구현한다.

6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.
    우선 맨 처음에는 파라미터를 추가하지 않고 Method를 하나 더 만들어서 해결하고 싶었다.
    recursion 함수가 더러워지는 게 싫었기 때문이다.
    하지만 그 방법은 떠오르지 않아서 가장 쉽게 생각할 수 있는 파라미터를 추가하는 방식을
    생각해서 풀었다. 다른 사람이 이 문제를 어떻게 풀었는지 검색할 예정이다 지금